from fastapi import FastAPI, HTTPException, Body, Depends, APIRouter
from typing import Optional, Any
from langchain_openai import ChatOpenAI
from dotenv import load_dotenv, find_dotenv
from pymongo import MongoClient
from datetime import datetime
from bson import ObjectId
import os
from typing import Dict, List, Optional, Any
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
import sys

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from agents.config import Config as config
from curator.services.curator_service import CuratorNode
from planner.services.planner_service import PlannerNode

from curator.utils.tools.search_tool import GoogleSearchTool
from curator.utils.tools.image_search_tool import GoogleImageSearchTool
from curator.utils.tools.message_logger import MessageHistoryLoggerTool
from curator.utils.tools.trip_inputs import UserDataLoggerTool
from curator.utils.tools.suggestions_logger import SuggestionDataLoggerTool
from planner.utils.tools.flight_search import FlightSearchTool
from planner.utils.tools.accommodation_search import AccommodationSearchTool

router = APIRouter(prefix="/api/agent")

# Define request and response models
class CuratorRequest(BaseModel):
    query: str = Field(..., description="User query for travel recommendations")
    conversation_id: str = Field(..., description="Unique identifier for the conversation")
    inputs: Optional[Dict] = Field(None, description="User inputs for the query")

class CuratorResponse(BaseModel):
    user_inputs: Dict[str, Any] = Field(..., description="User inputs extracted from the query")
    suggestions: Dict[str, Any] = Field(..., description="Curated travel suggestions")
    agent_message: str = Field(..., description="Agent's response message")
    CTAs: List[str] = Field(..., description="Call-to-action suggestions")
    plan_gen_flag: str = Field(..., description="Flag indicating if a plan should be generated")
    conversation_caption: str = Field(..., description="Caption for the conversation")

# Define request and response models
class PlannerRequest(BaseModel):
    conversation_id: str = Field(..., description="Unique identifier for the conversation/planning session")

class PlannerResponse(BaseModel):
    itinerary: Dict[str, Any] = Field(..., description="Itinerary generated by the planner")
    trip_details: Dict[str, Any] = Field(..., description="Detailed trip information")

# Initialize the model and tools
def get_curator():
    """
    Dependency to get the CuratorNode instance.
    """
    # Initialize the model
    model = ChatOpenAI(model="gpt-4o", temperature=0.2)
    
    # Define tools
    tools = [
        GoogleSearchTool(),
        GoogleImageSearchTool(),
        UserDataLoggerTool(),
        SuggestionDataLoggerTool(),
        MessageHistoryLoggerTool()
    ]
    
    # Initialize the CuratorNode
    curator = CuratorNode(model, tools)
    
    return curator

# Initialize the model and tools
def get_planner():
    """
    Dependency to get the PlannerNode instance.
    """
    # Initialize the model
    model = ChatOpenAI(model="gpt-4o", temperature=0.2)
    
    # Define tools
    tools = [
        FlightSearchTool(),
        AccommodationSearchTool()
    ]
    
    # Initialize the PlannerNode
    planner = PlannerNode(model, tools)
    
    return planner
    
@router.post("/curator", response_model=CuratorResponse)
async def curate(
    request: CuratorRequest,
    curator: CuratorNode = Depends(get_curator)
):
    """
    Endpoint to get curated travel suggestions based on user query.
    
    Args:
        request: CuratorRequest containing the user query and conversation ID
        background_tasks: FastAPI background tasks
        curator: CuratorNode instance (injected by FastAPI)
        
    Returns:
        CuratorResponse containing curated suggestions and agent message
    """
    try:
        # Call the curator service
        result = await curator(request.query, request.conversation_id, request.inputs)
        
        # Return the result
        return CuratorResponse(
            user_inputs=result.get("user_inputs", {}),
            suggestions=result.get("suggestions", {}),
            agent_message=result.get("agent_message", ""),
            CTAs=result.get("CTAs", []),
            plan_gen_flag=result.get("plan_gen_flag", "no"),
            conversation_caption=result.get("conversation_caption", "")
        )
    except Exception as e:
        # Log the error and return a 500 error
        print(f"Error in curator service: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error in curator service: {str(e)}")
    
@router.post("/planner", response_model=PlannerResponse)
async def plan(
    request: PlannerRequest,
    planner: PlannerNode = Depends(get_planner)
):
    """
    Endpoint to generate a detailed trip plan based on the current state.
    
    Args:
        request: PlannerRequest containing the current state and conversation ID
        planner: PlannerNode instance (injected by FastAPI)
        
    Returns:
        PlannerResponse containing the generated trip plan and updated state
    """
    try:
        # Call the planner service
        state = {
            "message_to_curator":{
                "conversation_id": request.conversation_id
            }
        }

        result = await planner(state)
        
        # Return the result wrapped in a PlannerResponse
        return result
    except Exception as e:
        # Log the error and return a 500 error
        print(f"Error in planner service: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error in planner service: {str(e)}")
    
@router.get("/health")
async def health_check():
    """
    Health check endpoint to verify the API is running.
    """
    return {"status": "healthy"}

app = FastAPI()
app.include_router(router)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allows all origins
    allow_credentials=True,
    allow_methods=["*"],  # Allows all methods
    allow_headers=["*"],  # Allows all headers
)
